[comment encoding = UTF-8 /]
[comment
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *     Michael Fiedler      - adapted for Bugzilla service provider
 *     Jad El-khoury        - initial implementation of code generator (422448)
 *     Matthieu Helleboid   - initialize each service provider separately
 *     Anass Radouani       - initialize each service provider separately
 *     Andrew Berezovskyi   - Minor changes for Bootstrap template (519699)
 *******************************************************************************/
/]

[module generateServiceProviderCatalogSingleton('http://org.eclipse.lyo/oslc4j/adaptorInterface')]

[import org::eclipse::lyo::oslc4j::codegenerator::services::services/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::serviceProviderCatalogServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::adaptorInterfaceServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::serviceProviderServices/]

[template public generateServiceProviderCatalogSingleton(aServiceProviderCatalog : ServiceProviderCatalog)]
[file (javaClassFullFileNameForSingleton(aServiceProviderCatalog), false, 'UTF-8')]
// [protected ('Copyright')]
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *     Michael Fiedler      - adapted for Bugzilla service provider
 *     Jad El-khoury        - initial implementation of code generator (422448)
 *     Matthieu Helleboid   - initialize each service provider separately
 *     Anass Radouani       - initialize each service provider separately
 *
 * This file is generated by org.eclipse.lyo.oslc4j.codegenerator
 *******************************************************************************/
// [/protected]

package [javaClassPackageNameForSingleton(aServiceProviderCatalog) /];

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response.Status;
import javax.ws.rs.core.UriBuilder;

import org.eclipse.lyo.oslc4j.core.model.Publisher;
import org.eclipse.lyo.oslc4j.core.model.Service;
import org.eclipse.lyo.oslc4j.core.model.ServiceProvider;
import org.eclipse.lyo.oslc4j.core.model.ServiceProviderCatalog;
import org.eclipse.lyo.oslc4j.core.OSLC4JUtils;

import [javaClassFullNameForAdaptorManager(containingAdaptorInterface(aServiceProviderCatalog)) /];
[for (aServiceProvider: ServiceProvider | aServiceProviderCatalog.serviceProviders)]
import [javaClassFullName(aServiceProvider) /];
[/for]

// [protected ('imports')]
// [/protected]

/**
 * This is the OSLC service provider catalog for the adapter.  Service providers are
 * not registered with the catalog until a request comes in to access either the catalog or a
 * specific service provider.   This request could be from an external consumer or an internal
 * request triggered by a consumer accessing a change request.
 *
 * Information about the desired list of ServiceProviders is retrieved from the Manager.getServiceProviderInfos() method.
 * A ServiceProvider is created and registered for each entry in that list.
 *
 * The registered service providers are refreshed on each catalog or service provider collection
 * request.
 */
public class [javaClassNameForSingleton(aServiceProviderCatalog) /]
{
    private static final ServiceProviderCatalog serviceProviderCatalog;
    [comment TODO: We here assume that 1 single
    serviceProvider type is specified in the SPCatalog. In the metamodel, a
    SPCatalog  can have 1+ serviceProvider types. For example, one SP type maps
    to the products. Another SP type maps to "something-else". In this case,
    each such SP type would need to define its name. (for example
    "ProductServiceProvider") In this case, loop through the SP types, and
    create a variable for each. You will also need to loop through and create
    the functions below for each such SP type. Alternatively, define
    serviceProviders as some Dictionary, where the key is the SP name, and the
    value is the SortedMap below/]
    private static final SortedMap<String, ServiceProvider> serviceProviders = new TreeMap<String, ServiceProvider>();

    static {
        serviceProviderCatalog = new ServiceProviderCatalog();
        URI catalogUri = UriBuilder.fromUri(OSLC4JUtils.getServletURI()).path("/catalog/singleton").build();
        serviceProviderCatalog.setAbout(catalogUri);
        serviceProviderCatalog.setTitle("[aServiceProviderCatalog.title /]");
        serviceProviderCatalog.setDescription("[aServiceProviderCatalog.description /]");
        [if (not aServiceProviderCatalog.publisher.oclIsUndefined())]
        serviceProviderCatalog.setPublisher(new Publisher("[aServiceProviderCatalog.publisher.title /]",
            "[aServiceProviderCatalog.publisher.identifier /]"));
        serviceProviderCatalog.getPublisher().setIcon(new URI("[aServiceProviderCatalog.publisher.icon /]"));
        [/if]
    }

    private [javaClassNameForSingleton(aServiceProviderCatalog) /]()
    {
        super();
    }


    public static URI getUri()
    {
        return serviceProviderCatalog.getAbout();
    }

    public static ServiceProviderCatalog getServiceProviderCatalog(HttpServletRequest httpServletRequest)
    {
        initServiceProviders(httpServletRequest);
        return serviceProviderCatalog;
    }

    public static ServiceProvider [ '[' ']' /] getServiceProviders(HttpServletRequest httpServletRequest)
    {
        synchronized(serviceProviders)
        {
            initServiceProviders(httpServletRequest);
            return serviceProviders.values().toArray(new ServiceProvider[ '[' /] serviceProviders.size()[ ']' /]);
        }
    }

    [for (aServiceProvider: ServiceProvider | aServiceProviderCatalog.serviceProviders)]

    private static URI construct[aServiceProvider.javaName(true)/]URI([aServiceProvider.instanceMethodSignature() /])
    {
        String basePath = OSLC4JUtils.getServletURI();
        Map<String, Object> pathParameters = new HashMap<String, Object>();
        [for (instanceCompositeID: String | aServiceProvider.instanceCompositeID()) separator(lineSeparator())]
        pathParameters.put("[instanceCompositeID /]", [instanceCompositeID /]);
        [/for]
        String instanceURI = "[aServiceProvider.instanceURI() /]";

        final UriBuilder builder = UriBuilder.fromUri(basePath);
        return builder.path(instanceURI).buildFromMap(pathParameters);
    }

    private static String [aServiceProvider.javaName(false)/]Identifier([aServiceProvider.instanceMethodSignature() /])
    {
        String identifier = [for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator('+')]"/" + [instanceCompositeID /][/for];
        return identifier;
    }

    public static ServiceProvider get[aServiceProvider.javaName(true)/](HttpServletRequest httpServletRequest, [aServiceProvider.instanceMethodSignature() /])
    {
        ServiceProvider serviceProvider;

        synchronized(serviceProviders)
        {
            String identifier = [aServiceProvider.javaName(false)/]Identifier([aServiceProvider.instanceMethodParameterList() /]);
            serviceProvider = serviceProviders.get(identifier);

            //One retry refreshing the service providers
            if (serviceProvider == null)
            {
                getServiceProviders(httpServletRequest);
                serviceProvider = serviceProviders.get(identifier);
            }
        }

        if (serviceProvider != null)
        {
            return serviceProvider;
        }

        throw new WebApplicationException(Status.NOT_FOUND);
    }

    public static ServiceProvider register[aServiceProvider.javaName(true)/](final HttpServletRequest httpServletRequest,
                                                          final ServiceProvider serviceProvider,
                                                          [aServiceProvider.instanceMethodSignature() /])
                                                throws URISyntaxException
    {
        synchronized(serviceProviders)
        {
            final URI serviceProviderURI = construct[aServiceProvider.javaName(true)/]URI([aServiceProvider.instanceMethodParameterList() /]);
            return register[aServiceProvider.javaName(true)/]NoSync(serviceProviderURI,
                                                 serviceProvider,
                                                 [aServiceProvider.instanceMethodParameterList() /]);
        }
    }

    /**
    * Register a service provider with the OSLC catalog
    *
    */
    private static ServiceProvider register[aServiceProvider.javaName(true)/]NoSync(final URI serviceProviderURI,
                                                                 final ServiceProvider serviceProvider
                                                                 [commaSeparate(aServiceProvider.instanceMethodSignature(), true, false)/])
    {
        final SortedSet<URI> serviceProviderDomains = getServiceProviderDomains(serviceProvider);

        String identifier = [aServiceProvider.javaName(false)/]Identifier([aServiceProvider.instanceMethodParameterList()/]);
        serviceProvider.setAbout(serviceProviderURI);
        serviceProvider.setIdentifier(identifier);
        serviceProvider.setCreated(new Date());
        serviceProvider.setDetails(new URI[ '[' ']' /] {serviceProviderURI});

        serviceProviderCatalog.addServiceProvider(serviceProvider);
        serviceProviderCatalog.addDomains(serviceProviderDomains);

        serviceProviders.put(identifier, serviceProvider);

        return serviceProvider;
    }

    // This version is for self-registration and thus package-protected
    static ServiceProvider register[aServiceProvider.javaName(true)/](final ServiceProvider serviceProvider[commaSeparate(aServiceProvider.instanceMethodSignature(), true, false)/])
                                            throws URISyntaxException
    {
        synchronized(serviceProviders)
        {
            final URI serviceProviderURI = construct[aServiceProvider.javaName(true)/]URI([aServiceProvider.instanceMethodParameterList()/]);

            return register[aServiceProvider.javaName(true)/]NoSync(serviceProviderURI, serviceProvider[commaSeparate(aServiceProvider.instanceMethodParameterList(), true, false)/]);
        }
    }

    public static void deregister[aServiceProvider.javaName(true)/]([aServiceProvider.instanceMethodSignature()/])
    {
        synchronized(serviceProviders)
        {
            final ServiceProvider deregisteredServiceProvider =
                serviceProviders.remove([aServiceProvider.javaName(false)/]Identifier([aServiceProvider.instanceMethodParameterList()/]));

            if (deregisteredServiceProvider != null)
            {
                final SortedSet<URI> remainingDomains = new TreeSet<URI>();

                for (final ServiceProvider remainingServiceProvider : serviceProviders.values())
                {
                    remainingDomains.addAll(getServiceProviderDomains(remainingServiceProvider));
                }

                final SortedSet<URI> removedServiceProviderDomains = getServiceProviderDomains(deregisteredServiceProvider);

                removedServiceProviderDomains.removeAll(remainingDomains);
                serviceProviderCatalog.removeDomains(removedServiceProviderDomains);
                serviceProviderCatalog.removeServiceProvider(deregisteredServiceProvider);
            }
            else
            {
                throw new WebApplicationException(Status.NOT_FOUND);
            }
        }
    }
    [/for]

    private static SortedSet<URI> getServiceProviderDomains(final ServiceProvider serviceProvider)
    {
        final SortedSet<URI> domains = new TreeSet<URI>();

        if (serviceProvider!=null) {
            final Service [ '[' ']' /] services = serviceProvider.getServices();
            for (final Service service : services)
            {
                final URI domain = service.getDomain();

                domains.add(domain);
            }
        }
        return domains;
    }

    /**
    * Retrieve the set of initial ServiceProviders as returned from the Manager.getServiceProviderInfos() method, and construct a service provider for each.
    *
    * Each ServiceProvider ID is added to the parameter map which will be used during service provider
    * creation to create unique URI paths for each ServiceProvider. 
    *
    */
    protected static void initServiceProviders (HttpServletRequest httpServletRequest)
    {
        try {
            // [protected ('initServiceProviders')]
            // [/protected]

            String basePath = OSLC4JUtils.getServletURI();
            [for (aServiceProvider: ServiceProvider | aServiceProviderCatalog.serviceProviders)]

            [javaClassName(aServiceProvider) /] [ '[' ']' /] [javaClassName(aServiceProvider).toLowerFirst()/]s = [javaClassNameForAdaptorManager(containingAdaptorInterface(aServiceProviderCatalog)) /].get[aServiceProvider.javaClassName()/]s(httpServletRequest);
            //Register each service provider
            for ([javaClassName(aServiceProvider) /] serviceProviderInfo : [javaClassName(aServiceProvider).toLowerFirst()/]s) {
                String identifier = [aServiceProvider.javaName(false)/]Identifier([for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator(', ')
                    ]serviceProviderInfo.[instanceCompositeID /][/for]);
                if (!serviceProviders.containsKey(identifier)) {
                    String serviceProviderName = serviceProviderInfo.name;
                    String title = String.format("Service Provider '%s'", serviceProviderName);
                    String description = String.format("%s (id: %s; kind: %s)",
                        "[aServiceProvider.description /]",
                        identifier,
                        "[aServiceProvider.title /]");
                    [if (aServiceProvider.publisher.oclIsUndefined())]
                    Publisher publisher = null;
                    [else]
                    Publisher publisher = new Publisher("[aServiceProvider.publisher.title /]", "[aServiceProvider.publisher.identifier /]");
                    [/if]
                    Map<String, Object> parameterMap = new HashMap<String, Object>();
                    [for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator(lineSeparator())]
                    parameterMap.put("[instanceCompositeID /]", serviceProviderInfo.[instanceCompositeID /]);
                    [/for]
                    final ServiceProvider aServiceProvider = [javaClassNameForFactory(aServiceProvider) /].createServiceProvider(basePath, title, description, publisher, parameterMap);
                    register[aServiceProvider.javaName(true)/](aServiceProvider, [for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator(', ')]serviceProviderInfo.[instanceCompositeID /][/for]);
                }
            }
            [/for]
        } catch (Exception e) {
            e.printStackTrace();
            throw new WebApplicationException(e,Status.INTERNAL_SERVER_ERROR);
        }
    }
}

[/file]
[/template]
